"use strict";(self.webpackChunkboardzilla_docs=self.webpackChunkboardzilla_docs||[]).push([[8260],{1620:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(5893),o=a(1151);const i={sidebar_position:7},s="UI",l={id:"game/ui",title:"UI",description:"You can customize the appearance and layout behaviour of all your game",source:"@site/docs/game/ui.md",sourceDirName:"game",slug:"/game/ui",permalink:"/game/ui",draft:!1,unlisted:!1,editUrl:"https://github.com/boardzilla/boardzilla-docs/tree/main/docs/game/ui.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Flow",permalink:"/game/flow"},next:{title:"Layout sandbox",permalink:"/game/layout-sandbox"}},r={},d=[{value:"React",id:"react",level:2},{value:"Layout",id:"layout",level:2},{value:"Layout parameters",id:"layout-parameters",level:2},{value:"Appearance",id:"appearance",level:2},{value:"Artwork",id:"artwork",level:3},{value:"SVG vs HTML",id:"svg-vs-html",level:2},{value:"Disable default",id:"disable-default",level:3},{value:"Effects",id:"effects",level:3},{value:"DOM",id:"dom",level:2},{value:"Components of the DOM",id:"components-of-the-dom",level:3},{value:"Animations",id:"animations",level:2}];function h(e){const t={a:"a",code:"code",div:"div",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"ui",children:"UI"}),"\n",(0,n.jsx)(t.p,{children:"You can customize the appearance and layout behaviour of all your game\nelements. In Boardzilla, it is easy to build the UI iteratively. By default\nBoardzilla renders all your game elements in a plain but visible way. It is\npossible to develop the entire game using the default UI, and only start\ncustomizing once all the rules are working. In many ways, the default UI is\neasier to use during development since when troubleshooting issues, you can\nsafely rule out the UI code."}),"\n",(0,n.jsx)(t.h2,{id:"react",children:"React"}),"\n",(0,n.jsxs)(t.p,{children:["The UI for Boardzilla is rendered in React. But there is very little React that\nyou need to know to work with the custom UI.  Essentially the only React skill\nthat is needed is to be able to write\n",(0,n.jsx)(t.a,{href:"https://www.w3schools.com/react/react_jsx.asp",children:"JSX"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"layout",children:"Layout"}),"\n",(0,n.jsx)(t.p,{children:"A layout is basically just a strategy for how items are visually placed inside\nother items. A layout might say that items should be laid out in a row, or a\nstack, or a grid. When many items enter the same space, it might say that they\nshould scale down to fit, should squish together, or that only a certain number\nshould actually be visible."}),"\n",(0,n.jsxs)(t.p,{children:["The Boardzilla layout engine works by applying different layout strategies to\neach game element on the board. By default each element has a very simple layout\nthat divides up its space equally to hold as many items as it has and fits them\nexactly within the allotted space. This is the layout you see when you start\nbuilding your board. Each layout strategy you apply creates a new invisible grid\nlayer on top in which things can fit. This invisible grid will grow or shrink as\nneeded to fill as much of the area as it can. Layouts are applied by calling\n",(0,n.jsx)(t.a,{href:"../api/classes/GameElement#layout",children:(0,n.jsx)(t.code,{children:"layout"})})," on an element or ",(0,n.jsx)(t.a,{href:"../api/classes/ElementCollection#layout",children:"group of\nelements"}),". When you apply a new layout\nto a space, you declare what element(s), or class of elements, it should apply\nto. Any element that enters this space gets put into one of the layouts\ndepending on whether it applies. If multiple layouts apply, Boardzilla\npriortizes ones that apply more specifically (e.g. a specific element overrides\none that applies to a class of elements). If none apply, it falls through to the\ndefault layout at the very bottom."]}),"\n",(0,n.jsx)(t.p,{children:"Each layout in a space operates completely independantly of the others in that\nspace. E.g. if you have a space that might have both Cards and Tokens in it and\nyou apply one layout to Cards and another to Tokens, each Card and Token in that\nspace will be laid out in accordance with its respective layout rules, but Cards\nwill not affect how Tokens are laid out, and vice versa. They are completely\nfree to overlap each other (with later layouts appearing over top of earlier\nones)."}),"\n",(0,n.jsx)(t.div,{style:{},"'center'}}":"",children:(0,n.jsx)(t.img,{src:"/img/layouts.png"})}),"\n",(0,n.jsx)(t.p,{children:"In the example pictured here, two layouts are declared for a space, one for\nCircle elements and one for Rectangle elements. Each declares a different grid\nfor their respective elements. When Circles and Rectangles are both added to the\nspace, they overlap each other without interfering with each others grid. The\nlast one declared (Rectangles) appears on top."}),"\n",(0,n.jsx)(t.h2,{id:"layout-parameters",children:"Layout parameters"}),"\n",(0,n.jsxs)(t.p,{children:["Creating a layout for an area of the board is a series of questions, with\ndifferent ",(0,n.jsx)(t.a,{href:"../api/modules#layoutattributes",children:"parameters"})," used to define each one."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["What part of the area should be used to display its contents? (",(0,n.jsx)(t.code,{children:"area"})," or\n",(0,n.jsx)(t.code,{children:"margin"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["How large should the grid be to accommodate its contents? (",(0,n.jsx)(t.code,{children:"rows"})," and\n",(0,n.jsx)(t.code,{children:"columns"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["How tightly should they be packed? (",(0,n.jsx)(t.code,{children:"gap"})," or ",(0,n.jsx)(t.code,{children:"offsetRow"}),"/",(0,n.jsx)(t.code,{children:"offsetColumn"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["Should they be in a square grid, or something non-orthogonal like a hexagon? (",(0,n.jsx)(t.code,{children:"gap"}),"\nor ",(0,n.jsx)(t.code,{children:"offsetRow"}),"/",(0,n.jsx)(t.code,{children:"offsetColumn"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["How should they fill up their grid as more are added? (",(0,n.jsx)(t.code,{children:"direction"}),",\n",(0,n.jsx)(t.code,{children:"alignment"})," and ",(0,n.jsx)(t.code,{children:"limit"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["How should they expand or squish to fit in the area? (",(0,n.jsx)(t.code,{children:"scaling"})," and ",(0,n.jsx)(t.code,{children:"maxOverlap"}),")"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["How all the parameters interact is somewhat technical. The best way to find what\nyou're looking for is to experiment. A helpful ",(0,n.jsx)(t.a,{href:"layout-sandbox",children:"layout sandbox"})," is provided here\nto let you try different parameters and see the results with different\nelements. Also browsing the sample games to see how their layouts work is a good\nresource. Of course, refer to ",(0,n.jsx)(t.a,{href:"../api/modules#layoutattributes",children:"the\ndocumentation"})," for the technical descriptions."]}),"\n",(0,n.jsxs)(t.p,{children:["Note that the layout code is evaluated every time the board changes, so if\ne.g. you have a layout for the cards in the deck, the supplied ",(0,n.jsx)(t.code,{children:"layout"})," might\nlooks like:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"$.deck.layout(Card, {\n  ...\n});\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This will be applied to each ",(0,n.jsx)(t.code,{children:"Card"})," in the ",(0,n.jsx)(t.code,{children:"deck"})," Space, and as cards enter or\nleave the deck, the layout will automatically be re-applied given the new set of\ncards in the deck."]}),"\n",(0,n.jsx)(t.h2,{id:"appearance",children:"Appearance"}),"\n",(0,n.jsx)(t.p,{children:"Getting the layout for your game elements is only one part of the UI. The other\nmajor piece is the appearance of each item. This is where you tell Boardzilla\nexactly what each item should look like"}),"\n",(0,n.jsx)(t.p,{children:"render"}),"\n",(0,n.jsx)(t.p,{children:"overrides"}),"\n",(0,n.jsx)(t.h3,{id:"artwork",children:"Artwork"}),"\n",(0,n.jsx)(t.h2,{id:"svg-vs-html",children:"SVG vs HTML"}),"\n",(0,n.jsx)(t.p,{children:"When it's time to add artwork"}),"\n",(0,n.jsx)(t.h3,{id:"disable-default",children:"Disable default"}),"\n",(0,n.jsx)(t.h3,{id:"effects",children:"Effects"}),"\n",(0,n.jsx)(t.h2,{id:"dom",children:"DOM"}),"\n",(0,n.jsx)(t.p,{children:"The game is displayed in the players browser using HTML and the data tree of the\nBoard described above is mapped to an actual tree in HTML. If you define a Space\nthat is a player's hand, with Pieces in them that are cards, then the DOM will\nliterally have a DOM element for each card as children of the DOM element\nrepresenting the hand. The class names of these will match the classes you\nprovide. So they're easy to target for CSS."}),"\n",(0,n.jsx)(t.h3,{id:"components-of-the-dom",children:"Components of the DOM"}),"\n",(0,n.jsx)(t.h2,{id:"animations",children:"Animations"})]})}function c(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>l,a:()=>s});var n=a(7294);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);