"use strict";(self.webpackChunkboardzilla_docs=self.webpackChunkboardzilla_docs||[]).push([[8260],{1620:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var t=n(5893),i=n(1151);const s={sidebar_position:7},r="UI",l={id:"game/ui",title:"UI",description:"You can customize the appearance and layout behaviour of all your game",source:"@site/docs/game/ui.md",sourceDirName:"game",slug:"/game/ui",permalink:"/game/ui",draft:!1,unlisted:!1,editUrl:"https://github.com/boardzilla/boardzilla-docs/tree/main/docs/game/ui.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Flow",permalink:"/game/flow"},next:{title:"Layout sandbox",permalink:"/game/layout-sandbox"}},o={},d=[{value:"React",id:"react",level:2},{value:"Layout",id:"layout",level:2},{value:"Layout parameters",id:"layout-parameters",level:2},{value:"Appearance",id:"appearance",level:2},{value:"Aspect ratio",id:"aspect-ratio",level:3},{value:"Render",id:"render",level:3},{value:"Stack multiple appearances",id:"stack-multiple-appearances",level:3},{value:"CSS",id:"css",level:3},{value:"Artwork",id:"artwork",level:3},{value:"SVG",id:"svg",level:3},{value:"Disable default",id:"disable-default",level:3},{value:"Effects",id:"effects",level:3},{value:"DOM",id:"dom",level:2},{value:"Components of the DOM",id:"components-of-the-dom",level:3},{value:"Animations",id:"animations",level:2}];function c(e){const a={a:"a",admonition:"admonition",code:"code",div:"div",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.h1,{id:"ui",children:"UI"}),"\n",(0,t.jsx)(a.p,{children:"You can customize the appearance and layout behaviour of all your game\nelements. In Boardzilla, it is easy to build the UI iteratively. By default\nBoardzilla renders all your game elements in a plain but visible way. It is\npossible to develop the entire game using the default UI, and only start\ncustomizing once all the rules are working. In many ways, the default UI is\neasier to use during development since when troubleshooting issues, you can\nsafely rule out the UI code."}),"\n",(0,t.jsx)(a.p,{children:"Like editing the rules, you can edit the UI in the devtools while you're in the\nmiddle of playtesting the game, watch your UI changes update in real-time, and\ncontinue to playtest, rewind and replay to see how your changes look."}),"\n",(0,t.jsx)(a.h2,{id:"react",children:"React"}),"\n",(0,t.jsxs)(a.p,{children:["The UI for Boardzilla is rendered in React. But there is very little React that\nyou need to know to work with the custom UI.  Essentially the only React skill\nthat is needed is to be able to write\n",(0,t.jsx)(a.a,{href:"https://www.w3schools.com/react/react_jsx.asp",children:"JSX"}),"."]}),"\n",(0,t.jsx)(a.h2,{id:"layout",children:"Layout"}),"\n",(0,t.jsx)(a.p,{children:"A layout is basically just a strategy for how items are visually placed inside\nother items. A layout might say that items should be laid out in a row, or a\nstack, or a grid. When many items enter the same space, it might say that they\nshould scale down to fit, should squish together, or that only a certain number\nshould actually be visible."}),"\n",(0,t.jsxs)(a.p,{children:["The Boardzilla layout engine works by applying different layout strategies to\neach game element on the board. By default each element has a very simple layout\nthat divides up its space equally to hold as many items as it has and fits them\nexactly within the allotted space. This is the layout you see when you start\nbuilding your board. Each layout strategy you apply creates a new invisible grid\nlayer on top in which things can fit. This invisible grid will grow or shrink as\nneeded to fill as much of the area as it can. Layouts are applied by calling\n",(0,t.jsx)(a.a,{href:"../api/classes/GameElement#layout",children:(0,t.jsx)(a.code,{children:"layout"})})," on an element or ",(0,t.jsx)(a.a,{href:"../api/classes/ElementCollection#layout",children:"group of\nelements"}),". When you apply a new layout\nto a space, you declare what element(s), or class of elements, it should apply\nto. Any element that enters this space gets put into one of the layouts\ndepending on whether it applies. If multiple layouts apply, Boardzilla\npriortizes ones that apply more specifically (e.g. a specific element overrides\none that applies to a class of elements). If none apply, it falls through to the\ndefault layout at the very bottom."]}),"\n",(0,t.jsx)(a.p,{children:"Each layout in a space operates completely independantly of the others in that\nspace. E.g. if you have a space that might have both Cards and Tokens in it and\nyou apply one layout to Cards and another to Tokens, each Card and Token in that\nspace will be laid out in accordance with its respective layout rules, but Cards\nwill not affect how Tokens are laid out, and vice versa. They are completely\nfree to overlap each other (with later layouts appearing over top of earlier\nones)."}),"\n",(0,t.jsx)(a.div,{style:{},"'center'}}":"",children:(0,t.jsx)(a.img,{src:"/img/layouts.png"})}),"\n",(0,t.jsx)(a.p,{children:"In the example pictured here, two layouts are declared for a space, one for\nCircle elements and one for Rectangle elements. Each declares a different grid\nfor their respective elements. When Circles and Rectangles are both added to the\nspace, they overlap each other without interfering with each others grid. The\nlast one declared (Rectangles) appears on top."}),"\n",(0,t.jsx)(a.h2,{id:"layout-parameters",children:"Layout parameters"}),"\n",(0,t.jsxs)(a.p,{children:["Creating a layout for an area of the board is a series of questions, with\ndifferent ",(0,t.jsx)(a.a,{href:"../api/modules#layoutattributes",children:"parameters"})," used to define each one."]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["What part of the area should be used to display its contents? (",(0,t.jsx)(a.code,{children:"area"})," or\n",(0,t.jsx)(a.code,{children:"margin"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:["How large should the grid be to accommodate its contents? (",(0,t.jsx)(a.code,{children:"rows"})," and\n",(0,t.jsx)(a.code,{children:"columns"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:["How tightly should they be packed? (",(0,t.jsx)(a.code,{children:"gap"})," or ",(0,t.jsx)(a.code,{children:"offsetRow"}),"/",(0,t.jsx)(a.code,{children:"offsetColumn"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:["Should they be in a square grid, or something non-orthogonal like a hexagon? (",(0,t.jsx)(a.code,{children:"gap"}),"\nor ",(0,t.jsx)(a.code,{children:"offsetRow"}),"/",(0,t.jsx)(a.code,{children:"offsetColumn"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:["How should they fill up their grid as more are added? (",(0,t.jsx)(a.code,{children:"direction"}),",\n",(0,t.jsx)(a.code,{children:"alignment"})," and ",(0,t.jsx)(a.code,{children:"limit"}),")"]}),"\n",(0,t.jsxs)(a.li,{children:["How should they expand or squish to fit in the area? (",(0,t.jsx)(a.code,{children:"scaling"})," and ",(0,t.jsx)(a.code,{children:"maxOverlap"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:["How all the parameters interact is somewhat technical. The best way to find what\nyou're looking for is to experiment. A helpful ",(0,t.jsx)(a.a,{href:"layout-sandbox",children:"layout sandbox"})," is provided here\nto let you try different parameters and see the results with different\nelements. Also browsing the sample games to see how their layouts work is a good\nresource. Of course, refer to ",(0,t.jsx)(a.a,{href:"../api/modules#layoutattributes",children:"the\ndocumentation"})," for the technical descriptions."]}),"\n",(0,t.jsxs)(a.p,{children:["Note that the layout code is evaluated every time the board changes, so if\ne.g. you have a layout for the cards in the deck, the supplied ",(0,t.jsx)(a.code,{children:"layout"})," might\nlook like:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"$.deck.layout(Card, {\n  ...\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["This will be applied to each ",(0,t.jsx)(a.code,{children:"Card"})," in the ",(0,t.jsx)(a.code,{children:"deck"})," Space, and as cards enter or\nleave the deck, the layout will automatically be re-applied given the new set of\ncards in the deck."]}),"\n",(0,t.jsx)(a.h2,{id:"appearance",children:"Appearance"}),"\n",(0,t.jsxs)(a.p,{children:["Getting the layout for your game elements is only one part of the UI. The other\nmajor piece is the appearance of each item. This is where you tell Boardzilla\nexactly what each item should look like. This is done by calling\n",(0,t.jsx)(a.a,{href:"../api/classes/GameElement#appearance",children:(0,t.jsx)(a.code,{children:"appearance"})})," on the elements you want\nto set. Like layout, this is re-evaluated as the board changes, so if you want\ne.g. ",(0,t.jsx)(a.code,{children:"Card"}),"'s to appear differently when they're in the deck vs the field, you\nmight call:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"$.deck.all(Card).appearance({\n  ...\n});\n\n$.field.all(Card).appearance({\n  ...\n});\n"})}),"\n",(0,t.jsx)(a.p,{children:"The different appearances given will be applied to Cards whenever they move\nbetween the deck and the field."}),"\n",(0,t.jsx)(a.h3,{id:"aspect-ratio",children:"Aspect ratio"}),"\n",(0,t.jsxs)(a.p,{children:["The first item you might set is the aspect ratio. This works in concert with the\n",(0,t.jsx)(a.a,{href:"#layout",children:(0,t.jsx)(a.code,{children:"layout"})})," to determine how items should fill up their space. If you\ngive e.g. every ",(0,t.jsx)(a.code,{children:"Card"})," an ",(0,t.jsx)(a.code,{children:"aspectRatio"})," of ",(0,t.jsx)(a.code,{children:"3 / 4"}),". It will appear in the\ncorrect proportions as it moves around the board, even though the different\nlayouts that it's in might scale it up or down. Typically ",(0,t.jsx)(a.code,{children:"Piece"}),"'s have aspect\nratios, while ",(0,t.jsx)(a.code,{children:"Space"}),"'s do not, since they are simply given a ",(0,t.jsx)(a.code,{children:"layout.area"})," to\nfill up."]}),"\n",(0,t.jsxs)(a.p,{children:["When you adjust the aspect ratio slider in the ",(0,t.jsx)(a.a,{href:"layout-sandbox",children:"layout sandbox"}),",\nit applies it to the pieces so you can see how layout and appearance work\ntogether."]}),"\n",(0,t.jsx)(a.h3,{id:"render",children:"Render"}),"\n",(0,t.jsxs)(a.p,{children:["To set the actual HTML of a game element, add a ",(0,t.jsx)(a.code,{children:"render"})," function to the\n",(0,t.jsx)(a.code,{children:"appearance"})," parameters. This is a function that provides an element of the\ncorrect type as its argument, and expects to have JSX returned to display that\nelement. Here's a simplified example of JSX to show a Card that has ",(0,t.jsx)(a.code,{children:"name"}),",\n",(0,t.jsx)(a.code,{children:"cost"})," and ",(0,t.jsx)(a.code,{children:"description"}),":"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-jsx",children:'  board.all(Card).appearance({\n    aspectRatio: 3 / 4,\n    render: card => (\n      <div>\n        <div className="name">{card.name}</div>\n        <div className="cost">{card.cost}</div>\n        <div className="description">{card.description}</div>\n      </div>\n    )\n  });\n'})}),"\n",(0,t.jsx)(a.p,{children:"You can put as much logic here as you like to conditionally display elements\ndifferently based on the state of the element, or of the game itself."}),"\n",(0,t.jsx)(a.admonition,{title:"render false",type:"tip",children:(0,t.jsxs)(a.p,{children:["Pass false to the ",(0,t.jsx)(a.code,{children:"render"})," attribute to tell Boardzilla not to render these elements at all"]})}),"\n",(0,t.jsxs)(a.p,{children:["Bear in the mind that the elements in a game might be\n",(0,t.jsx)(a.a,{href:"board#visibility",children:"invisible"})," to players (e.g. a flipped Card) in which case the\nproperties of the element will be ",(0,t.jsx)(a.code,{children:"undefined"}),". You can check for ",(0,t.jsx)(a.code,{children:"undefined"}),"\nproperties, or simply call\n",(0,t.jsx)(a.a,{href:"../api/classes/GameElement#isvisible",children:(0,t.jsx)(a.code,{children:"isVisible()"})})," to determine if\nthe back of the card should be displayed instead."]}),"\n",(0,t.jsx)(a.h3,{id:"stack-multiple-appearances",children:"Stack multiple appearances"}),"\n",(0,t.jsx)(a.p,{children:"If multiple appearance calls are made that apply to the same element, they are\nstacked on top of each other and only overwrite the values if provided. You\nmight, e.g. call"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"Card.appearance({ aspectRatio: 3 / 4 });\n"})}),"\n",(0,t.jsxs)(a.p,{children:["to set the aspect ratio of all ",(0,t.jsx)(a.code,{children:"Card"}),"'s, but then call"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"$.deck.all(Card).appearance({ render: ... })\n"})}),"\n",(0,t.jsx)(a.p,{children:"to set the appearance of cards more specifically in different board regions."}),"\n",(0,t.jsx)(a.h3,{id:"css",children:"CSS"}),"\n",(0,t.jsxs)(a.p,{children:["You can apply custom CSS to your elements in your game's CSS file. By default\nthe Boardzilla starter kit provides a blank CSS file using a Sass\npreprocessor. A full list of elements to target is ",(0,t.jsx)(a.a,{href:"css",children:"given here"}),". But for\nthe purposes of styling a particular game element, it's important to know that\nthe name of the element Class as defined in your game code is also the name of\nthe HTML class for the HTML Element, in other words a class named ",(0,t.jsx)(a.code,{children:"Card"})," will\nappear in the HTML as:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-html",children:'<div class="Card ... ">\n'})}),"\n",(0,t.jsxs)(a.p,{children:["In addition the properties you give to your card class, as well as built-in\nproperties like ",(0,t.jsx)(a.code,{children:"name"})," and ",(0,t.jsx)(a.code,{children:"player"})," are added to the HTML element as ",(0,t.jsx)(a.code,{children:"data-"}),"\nattributes, e.g.:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-html",children:'<div\n  class="Card ... "\n  data-name="ace-of-hearts"\n  data-suit="H"\n  data-number="1"\n>\n'})}),"\n",(0,t.jsxs)(a.admonition,{title:"player attribute",type:"tip",children:[(0,t.jsxs)(a.p,{children:["If an element is ",(0,t.jsx)(a.a,{href:"board#ownership",children:"assigned"})," to a player, this also causes a\n",(0,t.jsx)(a.code,{children:"data-player"})," attribute to be added. The value is the ",(0,t.jsx)(a.strong,{children:"seat position"})," of the\nplayer, e.g."]}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-html",children:'<div class="Hand ... " data-player="1">\n'})})]}),"\n",(0,t.jsxs)(a.p,{children:["These are here so you can target elements with different CSS as they change. If\nyou want to target the aces in a standard player deck represented with a ",(0,t.jsx)(a.code,{children:"Card"}),"\nclass that has a ",(0,t.jsx)(a.code,{children:"number"})," property, you can target:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-css",children:'.Card[data-number="1"] {\n'})}),"\n",(0,t.jsxs)(a.p,{children:["In this way, you can combine the ",(0,t.jsx)(a.code,{children:"appearance"})," JSX and the custom CSS to create\nanything you wish."]}),"\n",(0,t.jsxs)(a.admonition,{title:"HTML attributes are strings",type:"warning",children:[(0,t.jsx)(a.p,{children:"Remember that all HTML attributes are strings! Numbers and booleans are converted to strings."}),(0,t.jsxs)(a.p,{children:["If you have e.g. ",(0,t.jsx)(a.code,{children:"Card.active"})," as a boolean property, it will appear as:"]}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-html",children:'<div class="Card..." data-active="true">\n'})}),(0,t.jsx)(a.p,{children:"and must be targetted in CSS as:"}),(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-css",children:'.Card[data-active="true"] {\n'})})]}),"\n",(0,t.jsx)(a.h3,{id:"artwork",children:"Artwork"}),"\n",(0,t.jsx)(a.p,{children:"When it's time to add artwork to your game, this is as simple as adding the\nasset into your game directory, including it, and placing it into the relevant\nHTML element, e.g.:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-jsx",children:'  import cardArt from \'./assets/card-art.webp;\n\n  ...\n\n  board.all(Card).appearance({\n    aspectRatio: 3 / 4,\n    render: card => (\n      <div>\n        <img src={cardArt} />\n        <div className="name">{card.name}</div>\n      </div>\n    )\n  });\n'})}),"\n",(0,t.jsx)(a.p,{children:"Of course if you have multiple cards with different art, you may find this\neasier to do in the CSS. You can use the data attributes to target a specific\ncard, e.g.:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-css",children:'  .Card {\n    &[data-name="ace-of-hearts"] {\n      background-image: url(../assets/ace-of-hearts.webp);\n    }\n\n    &[data-name="ace-of-spades"] {\n      background-image: url(../assets/ace-of-spades.webp);\n    }\n\n    ...\n  }\n};\n\n'})}),"\n",(0,t.jsx)(a.h3,{id:"svg",children:"SVG"}),"\n",(0,t.jsxs)(a.p,{children:["Boardzilla will happily render SVG as well as HTML, either by importing an SVG\nassets and placing it into an ",(0,t.jsx)(a.code,{children:"<img src>"})," or by including ",(0,t.jsx)(a.code,{children:"<svg>"})," elements\ninside the render JSX. In practice, including ",(0,t.jsx)(a.code,{children:"<svg>"})," can be tricky for a couple\nof reasons."]}),"\n",(0,t.jsxs)(a.ol,{children:["\n",(0,t.jsxs)(a.li,{children:["SVGs in JSX require editing to make the ",(0,t.jsx)(a.a,{href:"https://react.dev/learn/writing-markup-with-jsx#converting-html-to-jsx",children:"attribute names\nJSX-friendly"}),". This\ntends to affect SVGs more than HTML."]}),"\n",(0,t.jsxs)(a.li,{children:["Dynamic content can be included in the SVG, e.g. ",(0,t.jsx)(a.code,{children:"<tspan>{card.cost}</tspan>"}),"\nas with HTML, however this can make it quite difficult to maintain a workflow\nfrom your SVG editor into Boardzilla"]}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:["For this reason, it is often easier to place static SVG's into ",(0,t.jsx)(a.code,{children:"<img>"})," tags and\nposition dynamic content over top of them in HTML. Alternatively for dynamic\ncontent, it may be easier to maintain separate source SVG's for every variation."]}),"\n",(0,t.jsx)(a.h3,{id:"disable-default",children:"Disable default"}),"\n",(0,t.jsx)(a.h3,{id:"effects",children:"Effects"}),"\n",(0,t.jsx)(a.h2,{id:"dom",children:"DOM"}),"\n",(0,t.jsx)(a.p,{children:"The game is displayed in the players browser using HTML and the data tree of the\nBoard described above is mapped to an actual tree in HTML. If you define a Space\nthat is a player's hand, with Pieces in them that are cards, then the DOM will\nliterally have a DOM element for each card as children of the DOM element\nrepresenting the hand. The class names of these will match the classes you\nprovide. So they're easy to target for CSS."}),"\n",(0,t.jsx)(a.h3,{id:"components-of-the-dom",children:"Components of the DOM"}),"\n",(0,t.jsx)(a.h2,{id:"animations",children:"Animations"})]})}function h(e={}){const{wrapper:a}={...(0,i.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>l,a:()=>r});var t=n(7294);const i={},s=t.createContext(i);function r(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);